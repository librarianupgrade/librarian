package com.strange.brokenapi.analysis.jdt.filter.error;

import cn.hutool.core.lang.Pair;
import cn.hutool.core.util.StrUtil;
import com.strange.common.utils.ClassUtil;
import com.strange.common.utils.JDTUtil;
import org.eclipse.jdt.core.compiler.IProblem;

import java.io.File;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class GetterFilter extends BaseErrorFilter {
    private static final Set<String> GETTER_ANNOTATION_SET = Set.of("lombok.Getter", "lombok.Data", "lombok.Value", "lombok.*");

    private final Map<String, File> javaCodeFileMap;

    public GetterFilter(Map<String, File> javaCodeFileMap) {
        super(javaCodeFileMap);
        this.javaCodeFileMap = javaCodeFileMap;
    }

    @Override
    public boolean filter(File sourceCodeFile, IProblem problem) {
        String[] arguments = problem.getArguments();

        // Remove the getter methods generated by @Data and @Getter
        if (arguments.length == 3 && (arguments[1].startsWith("get") || arguments[1].startsWith("is"))) {
            String className = ClassUtil.removeGenericType(arguments[0]);
            if (javaCodeFileMap.containsKey(className)) {
                File file = javaCodeFileMap.get(className);
                if (!validateGetterProblem(file, arguments[1])) {
                    return false;
                }
            } else {
                Pair<String, String> classPair = isInnerClass(className);
                if (classPair != null) {
                    // if is inner class
                    File tempFile = writeInnerClassToTempFile(classPair);
                    if (!validateGetterProblem(tempFile, arguments[1])) {
                        return false;
                    }
                } else {
                    // if is generic type class
                    Map<String, List<String>> genericBoundMapping = JDTUtil.getGenericBoundMapping(sourceCodeFile);
                    if (genericBoundMapping.containsKey(className)) {
                        for (String boundClassName : genericBoundMapping.get(className)) {
                            if (javaCodeFileMap.containsKey(boundClassName)) {
                                File file = javaCodeFileMap.get(boundClassName);

                                if (!validateGetterProblem(file, arguments[1])) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Remove the getter methods used in lambda function
        if (problem.getID() == PARAMETER_MISMATCH) {
            List<String> paramTypeList = ClassUtil.parseParamTypeList(arguments[3]);
            for (String paramType : paramTypeList) {
                paramType = paramType.strip();
                List<String> split = StrUtil.split(paramType, "::");
                if (split.size() == 2 && (split.get(1).startsWith("get") || split.get(1).startsWith("is"))) {
                    return false;
                }
            }
        }

        // Remove the Abstracted Not Implement cased by getter methods generated by @Data and @Getter
        if (problem.getID() == ABSTRACTED_METHOD_NOT_IMPLEMENT_ERROR && (arguments[0].startsWith("get") || arguments[0].startsWith("is"))) {
            String className = ClassUtil.removeGenericType(arguments[3]);
            if (javaCodeFileMap.containsKey(className)) {
                File file = javaCodeFileMap.get(className);

                if (!validateMissedGetterMethod(file, arguments[0])) {
                    return false;
                }
            }
        }

        return true;
    }

    private boolean validateMissedGetterMethod(File sourceCodeFile, String missedMethodName) {
        return validateMissedMethod(sourceCodeFile, missedMethodName, GETTER_ANNOTATION_SET);
    }

    private boolean validateGetterProblem(File sourceCodeFile, String missedMethodName) {
        if (!validateMissedGetterMethod(sourceCodeFile, missedMethodName)) return false;

        List<String> superClassList = JDTUtil.getSuperClassAndInterfaces(sourceCodeFile);
        for (String superClassName : superClassList) {
            superClassName = ClassUtil.removeGenericType(superClassName);
            if (javaCodeFileMap.containsKey(superClassName)) {
                if (!validateGetterProblem(javaCodeFileMap.get(superClassName), missedMethodName)) {
                    return false;
                }
            }
        }

        return true;
    }
}
