package com.strange.brokenapi.analysis.jdt.filter;

import cn.hutool.core.io.resource.ClassPathResource;
import cn.hutool.json.JSONUtil;
import com.strange.common.utils.IOUtil;
import org.eclipse.jdt.core.compiler.IProblem;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public interface ProblemFilter {
    Integer CONSTRUCTOR_ERROR = 134217858;

    Integer ABSTRACTED_METHOD_NOT_IMPLEMENT_ERROR = 67109264;

    Integer PARAMETER_MISMATCH = 67108979;

    Set<String> IGNORED_FILE_NAMES = Set.of("module-info.java", "package-info.java");

    //the above is the ignored error type id
    Integer INFER_ELIDED_TYPES_ERROR = 16778094;

    Integer HIERARCHY_ERROR = 16777543;

    Integer UNINITIALIZED_FINAL_FIELD = 33554513;

    Integer INFER_INVOCATION_TYPE_ERROR = 16778275;

    Integer DANGLING_REFERENCE_ERROR = 603979903;

    Integer TARGET_NOT_FUNCTIONAL_INTERFACE = 553648781;

    Integer UNCLASSIFIED = 0;

    // To filter the false positives generated by JDT during the analysis of syntax errors.
    Set<String> BLACK_LIST = initBlackList();

    static Set<String> initBlackList() {
        try (InputStream stream = new ClassPathResource("black.json").getStream()) {
            String json = IOUtil.readString(stream);
            List<String> list = JSONUtil.parseArray(json).toList(String.class);
            return new HashSet<>(list);
        } catch (IOException e) {
            System.out.println("ReadBlackError");
            throw new RuntimeException(e);
        }
    }

    boolean filter(File sourceCodeFile, IProblem problem);

}
