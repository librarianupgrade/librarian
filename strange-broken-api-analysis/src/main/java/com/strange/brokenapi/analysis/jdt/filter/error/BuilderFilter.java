package com.strange.brokenapi.analysis.jdt.filter.error;

import cn.hutool.core.lang.Pair;
import com.strange.common.utils.ClassUtil;
import com.strange.common.utils.JDTUtil;
import org.eclipse.jdt.core.compiler.IProblem;

import java.io.File;
import java.util.List;
import java.util.Map;

public class BuilderFilter extends BaseErrorFilter {
    private static final String BUILDER_ANNOTATION_NAME = "lombok.Builder";
    private static final String BUILDER_METHOD_NAME = "builder";
    private final Map<String, File> javaCodeFileMap;

    public BuilderFilter(Map<String, File> javaCodeFileMap) {
        super(javaCodeFileMap);
        this.javaCodeFileMap = javaCodeFileMap;
    }

    @Override
    public boolean filter(File sourceCodeFile, IProblem problem) {
        String[] arguments = problem.getArguments();

        // Remove the builder() generated by @Builder
        if (arguments.length == 3 && arguments[1].equals(BUILDER_METHOD_NAME)) {
            String className = ClassUtil.removeGenericType(arguments[0]);
            if (javaCodeFileMap.containsKey(className)) {
                File file = javaCodeFileMap.get(className);

                if (!validateBuilderProblem(file, arguments[1])) {
                    return false;
                }
            } else {
                Pair<String, String> classPair = isInnerClass(className);
                if (classPair != null) {
                    // if is inner class
                    File tempFile = writeInnerClassToTempFile(classPair);
                    if (!validateBuilderProblem(tempFile, arguments[1])) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    protected boolean validateMissedBuilderMethod(File sourceCodeFile, String missedMethodName) {
        List<String> classAnnotations = JDTUtil.getClassAnnotations(sourceCodeFile);
        if (classAnnotations.contains(BUILDER_ANNOTATION_NAME) && missedMethodName.equals(BUILDER_METHOD_NAME)) {
            return false;
        }
        return true;
    }

    protected boolean validateBuilderProblem(File sourceCodeFile, String missedMethodName) {
        if (!validateMissedBuilderMethod(sourceCodeFile, missedMethodName)) return false;

        List<String> superClassList = JDTUtil.getSuperClassAndInterfaces(sourceCodeFile);
        for (String superClassName : superClassList) {
            superClassName = ClassUtil.removeGenericType(superClassName);
            if (javaCodeFileMap.containsKey(superClassName)) {
                if (!validateMissedBuilderMethod(javaCodeFileMap.get(superClassName), missedMethodName)) {
                    return false;
                }
            }
        }

        return true;
    }
}
